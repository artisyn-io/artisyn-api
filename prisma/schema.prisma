// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  // output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
}

// Enum for user roles
enum UserRole {
  USER
  CURATOR
  ADMIN
}

// Enum for curator verification status
enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

// Enum for artisan type
enum ArtisanType {
  PERSON
  BUSINESS
}

// User model for both regular users and curators
model User {
  id                    String    @id @default(uuid())
  email                 String    @unique
  password              String
  walletAddress         String?   @unique
  firstName             String
  lastName              String
  role                  UserRole  @default(USER)
  avatar                String?
  bio                   String?
  phone                 String?
  googleId              String?   @db.VarChar(255)
  facebookId            String?   @db.VarChar(255)
  emailVerifiedAt       DateTime?
  emailVerificationCode String?   @db.VarChar(64)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  curator              Curator?
  artisans             Artisan[]
  reviews              Review[]              @relation("ReviewAuthor")
  receivedReviews      Review[]              @relation("ReviewTarget")
  reviewReports        ReviewReport[]        @relation("ReportReporter")
  sentTips             Tip[]                 @relation("TipSender")
  receivedTips         Tip[]                 @relation("TipReceiver")
  location             Location?             @relation(fields: [locationId], references: [id])
  personalAccessTokens PersonalAccessToken[] @relation("TokenUser")
  media                Media[]
  locationId           String?

  @@index([email])
  @@index([walletAddress])
  @@index([role])
}

// Media model for file storage and management
model Media {
  id           String   @id @default(uuid())
  filename     String
  originalName String
  mimeType     String
  size         Int
  path         String   @unique
  url          String?
  provider     String   @default("local") // local, s3, cloudinary, etc.
  userId       String?
  tags         String[]
  metadata     Json?    // width, height, etc.
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([provider])
  @@map("media")
}

// User personal access token model
model PersonalAccessToken {
  id         String    @id @default(uuid())
  userId     String
  name       String
  token      String    @unique @db.Text
  abilities  Json?
  lastUsedAt DateTime?
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  user User @relation("TokenUser", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("personal_access_token")
}

// User password resets model
model PasswordCodeResets {
  id        String   @id @default(uuid())
  email     String?
  phone     String?
  code      String   @db.VarChar(64)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@map("password_code_resets")
}

// Curator profile model
model Curator {
  id                 String             @id @default(uuid())
  userId             String             @unique
  verificationStatus VerificationStatus @default(PENDING)
  specialties        String[]
  experience         Int // Years of experience
  portfolio          String? // URL to portfolio
  certificates       String[] // URLs to certificates
  verifiedAt         DateTime?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([verificationStatus])
}

// Category model
model Category {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  icon        String? // URL to category icon
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  subcategories Subcategory[]
  artisans      Artisan[]

  @@index([name])
}

// Subcategory model
model Subcategory {
  id          String   @id @default(uuid())
  name        String
  description String?
  categoryId  String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  category Category  @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  artisans Artisan[]

  @@unique([name, categoryId])
  @@index([categoryId])
}

// Artisan model
model Artisan {
  id            String      @id @default(uuid())
  name          String
  email         String?
  phone         String?
  avatar        String?
  type          ArtisanType @default(PERSON)
  description   String
  price         Float? // Optional price if fixed
  priceRange    Json? // Min and max price if variable
  images        String[] // URLs to artisan images
  curatorId     String // User ID of the curator
  categoryId    String
  subcategoryId String?
  locationId    String
  isActive      Boolean     @default(true)
  isVerified    Boolean     @default(false)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  archivedAt    DateTime?

  // Relations
  curator     User         @relation(fields: [curatorId], references: [id], onDelete: Cascade)
  category    Category     @relation(fields: [categoryId], references: [id])
  subcategory Subcategory? @relation(fields: [subcategoryId], references: [id])
  location    Location     @relation(fields: [locationId], references: [id])
  reviews     Review[]
  tips        Tip[]

  @@index([curatorId])
  @@index([categoryId])
  @@index([subcategoryId])
  @@index([locationId])
  @@index([isActive])
}

// Location model for geospatial data
model Location {
  id         String   @id @default(uuid())
  address    String?
  city       String
  state      String
  country    String
  postalCode String?
  latitude   Float
  longitude  Float
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  users    User[]
  artisans Artisan[]

  @@index([city])
  @@index([state])
  @@index([country])
  @@index([latitude, longitude])
}

// Review model
model Review {
  id         String       @id @default(uuid())
  rating     Int // 1-5 star rating
  comment    String?
  authorId   String // User who wrote the review
  targetId   String // User who received the review (curator)
  artisanId  String? // Optional artisan reference
  status     ReviewStatus @default(PENDING)
  moderatedBy String? // Admin who moderated the review
  moderatedAt DateTime?
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  // Relations
  author   User            @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  target   User            @relation("ReviewTarget", fields: [targetId], references: [id], onDelete: Cascade)
  artisan  Artisan?        @relation(fields: [artisanId], references: [id], onDelete: SetNull)
  response ReviewResponse?
  reports  ReviewReport[]

  @@index([authorId])
  @@index([targetId])
  @@index([artisanId])
  @@index([rating])
  @@index([status])
}

// Review Response model (curator replies to reviews)
model ReviewResponse {
  id        String   @id @default(uuid())
  reviewId  String   @unique // One response per review
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  @@index([reviewId])
  @@map("review_responses")
}

// Review Report model (abuse detection and reporting)
model ReviewReport {
  id         String       @id @default(uuid())
  reviewId   String
  reporterId String // User who reported
  reason     ReportReason
  details    String? // Additional details
  status     ReportStatus @default(PENDING)
  resolvedBy String? // Admin who resolved
  resolvedAt DateTime?
  resolution String? // Resolution notes
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  // Relations
  review   Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  reporter User   @relation("ReportReporter", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([reviewId])
  @@index([reporterId])
  @@index([status])
  @@map("review_reports")
}

// Enum for tip status
enum TipStatus {
  PENDING
  COMPLETED
  CANCELLED
  REFUNDED
}

// Tip model for payments between users
model Tip {
  id         String    @id @default(uuid())
  amount     Float
  currency   String    @default("ETH")
  message    String?
  status     TipStatus @default(PENDING)
  senderId   String // User who sent the tip
  receiverId String // User who received the tip
  artisanId  String? // Optional artisan reference
  txHash     String? // Transaction hash on blockchain
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  sender   User     @relation("TipSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User     @relation("TipReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  artisan  Artisan? @relation(fields: [artisanId], references: [id], onDelete: SetNull)

  @@index([senderId])
  @@index([receiverId])
  @@index([artisanId])
  @@index([status])
  @@index([txHash])
}

// Enum for review moderation status
enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

// Enum for review report status
enum ReportStatus {
  PENDING
  REVIEWED
  DISMISSED
  ACTION_TAKEN
}

// Enum for report reason
enum ReportReason {
  SPAM
  INAPPROPRIATE
  FAKE
  HARASSMENT
  OFF_TOPIC
  OTHER
}

// Enum for analytics event types
// Also serves as the activity logging event taxonomy
enum EventType {
  API_CALL
  USER_SIGNUP
  USER_LOGIN
  ARTISAN_CREATED
  ARTISAN_UPDATED
  ARTISAN_VIEWED
  CONTACT_INFO_ACCESSED
  LISTING_ENGAGEMENT
  REVIEW_CREATED
  REVIEW_UPDATED
  REVIEW_APPROVED
  REVIEW_REJECTED
  REVIEW_RESPONDED
  REVIEW_REPORTED
  TIP_SENT
  CATEGORY_VIEWED
  SEARCH_PERFORMED
  ERROR_OCCURRED
  // Security / activity-focused events
  LOGIN_FAILED
  PASSWORD_RESET_REQUESTED
  ADMIN_ACTION
}

// Analytics Event model for tracking user interactions and API usage
model AnalyticsEvent {
  id             String    @id @default(uuid())
  eventType      EventType
  anonymizedUserId String?  // Hashed/anonymized user identifier for GDPR compliance
  endpoint       String?   // API endpoint that was called
  method         String?   // HTTP method (GET, POST, etc.)
  statusCode     Int?      // HTTP response status code
  responseTime   Int?      // Response time in milliseconds
  userAgent      String?   // Anonymized user agent info
  ipHash         String?   // Hashed IP address for privacy
  referrer       String?   // Referring URL (anonymized)
  metadata       Json?     // Additional event-specific data
  createdAt      DateTime  @default(now())

  @@index([eventType])
  @@index([createdAt])
  @@index([anonymizedUserId])
  @@index([endpoint])
  // Composite indexes to speed up common activity queries
  @@index([eventType, createdAt])
  @@index([anonymizedUserId, eventType, createdAt])
  @@map("analytics_events")
}

// Analytics Aggregation model for periodic reports
model AnalyticsAggregation {
  id             String   @id @default(uuid())
  periodType     String   // 'hourly', 'daily', 'weekly', 'monthly'
  periodStart    DateTime
  periodEnd      DateTime
  eventType      EventType
  eventCount     Int      @default(0)
  avgResponseTime Float?  // Average response time for API calls
  uniqueUsers    Int      @default(0)
  metadata       Json?    // Additional aggregated metrics
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([periodType, periodStart, eventType])
  @@index([periodType])
  @@index([periodStart])
  @@index([eventType])
  @@map("analytics_aggregations")
}
